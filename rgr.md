# Архітектура програмного забезпечення

## Розрахункова-графічна робота

#### Тема: Архітектурні діаграми та бенчмарки
#### Мета: Закріплення навичок ілюстрації організації програмних систем та оцінки часу виконання алгоритмів

### Завдання
1. Для 2-гої роботи, підтвердьте лінійний час виконання вашої функції перетворення
чи обчислення вхідного виразу.
2. Для 3-тої роботи, побудуйте діаграму взаємодії компонентів у вашій
імплементації.
3. Для 4-ої роботи, побудуйте діаграму взаємодії для вашої реалізації (на ній, скоріш за все, мають опинитися компоненти парсера, черги команд, ядра цикла) та підтвердьте лінійний час роботи вашого парсера команд.

## Хід виконання

### Завдання 1

Щоб довести лінійний час виконання функції перетворення вхідного виразу `PrefixToInfix` ми в файлі [implementation_test.go](https://github.com/Scopics/architecture-lab-2/blob/master/implementation_test.go) додаємо бенчмарк, де будемо запускати нашу функцію з аргументами різної довжини та робити заміри часу: 

```go
var res string

func BenchmarkPrefixToInfix(b *testing.B) {
	str := "- * / 15 - 7 + 1 1 3 + 2 + 1 + 9 "
	for i := 1; i <= 20; i++ {
		testStr := strings.Repeat(str, i*i) + "1"
		b.Run(fmt.Sprintf("%d-operators", i*i*8), func(b *testing.B) {
			res, _ = PrefixToInfix(testStr)
		})
	}
}
```

В цьому бенчмарку ми маємо заготовлений вираз, в якому не вистачає останнього операнда, ми його будемо потворювати n-ну кількість разів (у нашому випадку на `i²`) та в кінець дописувати у якості відсутнього останнього операнда одиницю, таким чином ми досягаємо різної кількості операторів на кожному кроці (і звичайно ж різну довжину аргумента), на першій ітерації операторів 8, на другій 32 і так далі, аж до 3200, для наших замірів даної вибірки буде достатньо. Також як можна помітити ми записуємо результат виконання функції в глобальну змінну `res`, це виконано для того, щоб уникати оптимізації компілятора, котрий може помітити, що результат чистої функції ніде не використовується і прибере її виклики.

Також було прийнято рішення, задля покращення і уточнення результатів бенчмаркінгу, проганяти бенчмарки не на персональних локальних машинах (адже тут купа процесів, що можуть вплинути на результат, наприклад запис якоїсь статистики ситеми тощо, під час замірів), а на віддаленому сервері, в ідеалі було б мати чистий арендований сервер і підключитись до нього за допомогою ssh, та налаштувати все власноруч, але ми скористаємось згенерованим мінмальним `workspace` для `golang cli` від `GitPod`. Нижче наведено список активних процесів:
![](./assets/img/ps.png)

Далі запускаємо команду `go test -bench . -cpu 1`, прапором `-bench` ми говоримо, що запускаємо саме бенчмарки, а `-cpu 1` що ми запускаємо бенчмарки тільки на 1 ядрі процесора. У результаті ми отримали:
![](./assets/img/bench-l2.png)

Тепер перенесемо точки в `Google Tables` та побудуємо графік, реузльтат наведено нижче:

![](./assets/img/data-l2.png)

Як бачимо з графіку вище, всі точки не розташовуються рівно по лінії, це зумовлено тим, що хоч ми й запускали бенчмарк на машині з досить малою кількістю процесів, але все ж запуск відбувавсь не в ідеальних умовах (як бачимо зі списку процесів, є мережеві процеси і ще інші, тому цілком можливо що в момент запуску бенчмарку ми наприклад почати зчитувати дані з якогось сокету, тощо). Але можна сказати, аналізуючи результат графіку, що результат є наближеним до лінійного. 

## Додатки
### Додаток 1
Сирцевий код аналізу лінійної регресії на `python`
```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as st
sns.set_style('whitegrid')

data = pd.read_csv("benchmark1.csv")
sns.lineplot(x=data["Operators"], y=data["Time"], label="Benchmark data")

lr = st.linregress(data.iloc[:, 0], data.iloc[:, 1])
line = data["Operators"] * lr.slope + lr.intercept
sns.lineplot(x=data["Operators"], y=line, label="Linear regression")

plt.title(f"Нахил прямої: {lr.slope:.5f}\nТочка перетину: {lr.intercept:.5f} \nКоефiцiєнт кореляцiї: {lr.rvalue:.5f}")
plt.ylabel("Time")
plt.xlabel("Operators")
plt.legend()
plt.get_current_fig_manager().set_window_title('Benchmark results')
plt.show()
```
